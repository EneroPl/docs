# **Адаптер (service)**

# **Содержание**

- [**Файловая структура модуля**](structure.md)
  - [**assets/**](assets.md)
  - [**helpers/**](helpers.md)
  - [**tests/**](tests.md)
  - [**Слой отображения (components/)**](component.md)
- [**Сущности (entity)**](entity.md)
- [**Абстракции (interfaces)**](interfaces.md)
- [**Адаптер (service)**](service.md)
- [**Репозиторий (API)**](api.md)
- [**Глобальное хранилище**](store.md)

#

Наш адаптер, который решала всех вопросов и помошник слою отображения. В нём реализована вся работа с бизнес-логикой. Пример инициализации адаптера:

```typescript
export default class UserService implements IUserServiceInstance {
  api: IUserApi;
  store: IUserStorage;
  
  constructor ({ api, store }: IUserServiceConstructor) {
    this.api = api;
    this.store = store;
  }

  async getUsers(): Promise<TUser[]> {
    return await this.api.getUsers();
  }
}
```

## **Зависимости**

Мы часто пишем какой-то модуль, используя API для получения (и тд) необходимых данных с сервера. Так вот это является зависимостью, как и любой другой слой, который необходим нашему адаптару.

Крайне не рекомендуется импортировать какие-то зависимости внутри адаптера. Вместо этого передайте его в качестве зависимости:

```typescript
// Плохо
import i18n from 'i18n';

// Хорошо
...
constructor ({ i18n }) {
  this.i18n = i18n;
}
...
```

## **Конструктор адаптера**

Адаптер, как и сущность, не имеет возможности хранить на уровне файла какие-либо внешние пакеты, поэтому они определяются в `constructor` в качестве зависимости как `entity`.

Также, адаптер не умеет хранить в себе промежуточные данные (просто у него лапки). Поэтому, **НЕ** допускается использования `constructors` в качестве хранилища промежуточных данных\состояний. Абсолютно по этой же причине **НЕ** допускается хранение состояния компонентов на уровне адаптера.

```typescript
// Плохо. В конструкторе какие-то данные о состоянии.
export default class UserService implements IUserServiceInstance {
  api: IUserApi;
  store: IUserStorage;
  
  constructor ({ api, store }: IUserServiceConstructor) {
    this.api = api;
    this.store = store;
    this.isLoading = false; <-- НЕЛЬЗЯ
  }
}
```

Чтобы обеспечить компонента данными таким образом, чтобы у вас не возникали вопросы по типу: "А где тогда определить стейт, если это мне нужно в нескольких местах?" Ответ: "На странице".

## **Методы адаптера**

Методы адаптера по определению схожи с понятием инструкции. Если компонент просит нас выполнить какое-то действие, то мы производим некоторые манипуляции, которые необходимы для получения и отдачи результата. В принципе, здесь не так уж и сложно:

1. Пошёл попросил данные у API's / store;
2. Если нужно, преобразовал что-то шурук-мурук;
2. Если нужно, залил что-то актуальное в store;
3. Вернул компоненту то, что он ожидает

Примерно по такому абстрактному принципу будет работь каждый метод, даже если в вашем сервайсе возникнит какая-то специфика.
